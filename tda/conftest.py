import pytest
import contextlib
import os
import release_version_manager as ReleaseVersion
import random as real_random
import subprocess
import urllib.parse
import atexit
import yaml
from typing import NamedTuple
import requests
from pathlib import Path

from selenium import webdriver
from appium import webdriver as appiumdriver
from appium.options.android import UiAutomator2Options
from appium.options.ios import XCUITestOptions
from selenium.common.exceptions import WebDriverException
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.safari.options import Options as SafariOptions
from datetime import datetime, timedelta, timezone
from urllib.parse import urlencode

import sentry_sdk

def get_system_user():
    return subprocess.check_output(['id', '-un']).strip().decode()

def is_running_in_gcp():
    try:
        # Google Compute Engine instances have a metadata server available at this URL
        metadata_url = "http://metadata.google.internal"
        headers = {'Metadata-Flavor': 'Google'}
        response = requests.get(metadata_url, headers=headers, timeout=2)
        return response.status_code == 200
    except requests.exceptions.RequestException:
        return False

def is_running_in_gha():
    return os.getenv('GITHUB_ACTIONS') == 'true'

def is_production():
    return is_running_in_gcp() or is_running_in_gha()

# Get current timestamp, with +/- adjustment if desired, as string in ISO format (for Sentry URLs)
# round seconds down (floor): adjust_seconds = 0
# round seconds up (ceil): adjust_seconds = 1
def get_current_time_iso_utc(adjust_seconds=0):
    dt = datetime.now(timezone.utc).replace(microsecond=0) + timedelta(seconds = adjust_seconds)
    return dt.strftime('%Y-%m-%dT%H:%M:%S')


# Example command usage:
#
#   RUN_ID=test_desktop_web_13 BATCH_SIZE=10 py.test -n 6 desktop_web
#

start_time = get_current_time_iso_utc()


class Browser(NamedTuple):
    remote: bool
    browserName: str
    browserVersion: str | None = None
    platformName: str | None = None
    param_display: str | None = None


class Config(NamedTuple):
    # TDA can operate in two modes, 'mock' and 'direct'
    # mock - captures a small sample of data using mini-relay, stores it, then clones those events
    # fudging timestamps and other fields to make it look like they were generated by the app
    # direct - just sends data directly to Sentry
    mode: str
    browsers: tuple[Browser, ...]
    dsn: str
    react_endpoints: tuple[str, ...]
    vue_endpoints: tuple[str, ...]


def _config() -> Config:
    cfg_filename = os.environ.get('TDA_CONFIG', 'config.yaml')
    with open(cfg_filename) as f:
        contents = yaml.safe_load(f)
    return Config(
        mode=contents['mode'],
        browsers=tuple(Browser(**d) for d in contents['browsers']),
        dsn=contents['dsn'],
        react_endpoints=tuple(contents['react_endpoints']),
        vue_endpoints=tuple(contents['vue_endpoints']),
    )

CONFIG = _config()

# optional, for tda-mock no need to specify as it will be set to request nodeid
RUN_ID = os.getenv("RUN_ID")

# We don't really need true randomness for anything. Graphs could look similar after TDA restarts due
# to same batch size sequence, but no one would notice. Saucelabs introduces some randomness anyway.
REPEATABLE_RANDOM = False

# BATCH_SIZE can be either <NUMBER> or random_<NUMBER>
# The later means each time a test is run the inner steps will be repeated a random
# number of times between 0 and <NUMBER> - 1
# e.g. BATCH_SIZE=5, or BATCH_SIZE=random_100
# IS_CANARY always overrides BATCH_SIZE
BATCH_SIZE = os.getenv("IS_CANARY") and "1" or (os.getenv("BATCH_SIZE") or "1")

SLEEP_LENGTH = os.getenv("SLEEP_LENGTH") or "random_2_1"

# Currently only used in desktop_web/ tests. Mobile apps have it hardcoded.
BACKENDS = (os.getenv("BACKENDS") or "flask,express,springboot,ruby,laravel,rails,aspnetcore").split(',')

import urllib3
urllib3.disable_warnings()


def get_environment():
    hostname = subprocess.check_output(['hostname']).strip().decode()
    host_to_env = {
        'empower-tda-and-crons': 'production',
        'empower-tda-and-crons-staging': 'staging',
    }
    if hostname in host_to_env:
        return host_to_env[hostname]
    else:
        return 'local'


sentry_sdk.init(
    dsn=CONFIG.dsn,
    traces_sample_rate=0,
    # we don't really use environment for anything, as we'd have to propagate it to all
    # the other services, so instead out of laziness we effectively just encode it as the
    # first part of SE tag ("prod-", or system $USER when running locally).
    environment=get_environment()
)

_browser2class = {
    'chrome': ChromeOptions,
    'firefox': FirefoxOptions,
    'safari': SafariOptions
}

def pytest_addoption(parser):
    parser.addoption("--dc", action="store", default='us', help="Set Sauce Labs Data Center (US or EU)")

@pytest.fixture
def data_center(request):
    return request.config.getoption('--dc')

@pytest.fixture
def random(request):
    if REPEATABLE_RANDOM:
        # Ensure tests produce repeatable outcomes when re-run, see:
        cwd = os.path.dirname(os.path.realpath(__file__)) + '/'
        test_relpath = str(request.path).split(cwd)[1]
        # e.g: desktop_web/test_mytest.py:test_myfunction[desktop_web_driver0]
        seed = f'{test_relpath}:{request.node.name}'
        # Use a new Random object doesn't share state with global random generator
        # this is just in case some package uses global random in a way that would
        # upset repeatability (e.g. numer of random() calls varies b/w executions)
        return real_random.Random(seed)
    else:
        return real_random

# random_1.5
# random_3_1.0
# 5.5
@pytest.fixture
def sleep_length(random):
    def random_sleep_length():
        if SLEEP_LENGTH.startswith("random_"):
            spl = SLEEP_LENGTH.split('_')
            r = random.randrange(int(spl[1]))
            if len(spl) == 3:
                r += float(spl[2])
            return r
        else:
            r = random.random() # unused, to make sure we call random same number of times
            return float(SLEEP_LENGTH)
    return random_sleep_length


@pytest.fixture
def batch_size(random):
    if BATCH_SIZE.startswith("random_"):
        return random.randrange(int(BATCH_SIZE.split('_')[1]))
    else:
        r = random.random() # unused, to make sure we call random same number of times
        return int(BATCH_SIZE)

@pytest.fixture
def backend(random):
    def random_backend(exclude=[], include=[]):
        if not include:
            include = BACKENDS
        else:
            include = [include] if isinstance(include, str) else include

        exclude = [exclude] if isinstance(exclude, str) else exclude
        # Must sort to get same order across processes to ensure that seeded random.sample()
        # always returns the same values.
        # python3
        #   >>> list(set(['b', 'a', 'f', 'd', 'e', 'c']) - set(['c', 'a']))
        #   ['b', 'd', 'e', 'f']
        #   >>> list(set(['b', 'a', 'f', 'd', 'e', 'c']) - set(['c', 'a']))
        #   ['b', 'd', 'e', 'f']
        #   >>> exit()
        # python3
        #   >>> list(set(['b', 'a', 'f', 'd', 'e', 'c']) - set(['c', 'a']))
        #   ['d', 'f', 'b', 'e']
        backends = sorted(list(set(include) - set(exclude)))
        if 'flask' in backends:
            backends += ['flask'] # make flask 2x more likely than others
        return random.sample(backends, 1)[0]
    return random_backend


# returns number of "release weeks" since 2022-01-01 (???)
# see react/src/utils/time.js
def get_release_week():
    release = subprocess.run(['../bin/release.sh'], stdout=subprocess.PIPE).stdout.decode().strip()
    year, month, week = map(int, release.split('.'))
    past_years = (year - 22) * 59 - (year - 21) // 4
    return past_years + (month - 1) * 5 + (-1 if month > 2 and year % 4 != 0 else 0) + week

class CExp:
    STANDARD_CHECKOUT_FAIL  = "standard_checkout_fail"
    PRODUCTS_EXTREMELY_SLOW = "products_extremely_slow"
    PRODUCTS_BE_ERROR       = "products_be_error"
    ADD_TO_CART_JS_ERROR    = "add_to_cart_js_error"
    CHECKOUT_SUCCESS        = "checkout_success" 


# Simulate critical experiences (cexp) in user journey
@pytest.fixture
def cexp(random):

    # 1, 2, 3, ... each has it's own probablitiy of certain types of failures
    def time_segment():
        now = datetime.now()

        # ideally these are correlated with release timestamps (vertical bars in graphs):
        #return get_release_week() % 2

        # OR, for testing cycle through 4 segements every hour (15 minutes each)
        #return now().minute // 15

        # testing cycle through 5 segements every 2 hours (15/30 minutes each)
        #if now.hour % 2 == 0:
        #    if now.minute < 30: 
        #        return 0
        #    elif now.minute < 45:
        #        return 1
        #    else:
        #        return 2
        #else:
        #    return 3 + now.minute // 30

        # change every hour, except for segment #4 that's 2 hours long (cycle = 6 hours)
        #mod5 = now.hour % 6 
        #return 4 if mod5 == 5 else mod5
        
        # change every 4 hours, except for segment #4 that's 8 hours long (cycle = 24 hours)
        d4 = now.hour // 4
        return 4 if d4 == 5 else d4

    # array length must match number of possible time segments
    probabilities = {       # segments    0    1    2    3    4 
        CExp.STANDARD_CHECKOUT_FAIL:    [1.0, 0.0, 0.0, 0.0, 0.0],
        CExp.PRODUCTS_EXTREMELY_SLOW:   [0.0, 1.0, 0.0, 0.0, 0.0],
        CExp.PRODUCTS_BE_ERROR:         [0.0, 0.0, 1.0, 0.0, 0.0],
        CExp.ADD_TO_CART_JS_ERROR:      [0.0, 0.0, 0.0, 1.0, 0.0],
        CExp.CHECKOUT_SUCCESS:          [0.0, 0.0, 0.0, 0.0, 1.0],
    }
    
    def random_cexp():
        return random.choices(
            list(probabilities.keys()),
            weights=list(probabilities.values())[time_segment()],
            k=1)[0]

    return random_cexp


@pytest.fixture
def endpoints():
    return CONFIG


class _ExtraParams:
    def __init__(self, *args, extra_params, **kwargs):
        if extra_params.startswith(('&', '?')):
            raise ValueError('extra_params must be in format: "param1=value1&param2=value2..."')
        self.extra_params = extra_params
        super().__init__(*args, **kwargs)

    def get(self, url):
        url += ('&' if '?' in url else '?') + self.extra_params
        return super().get(url)

# Automatically append a set of extra parameters to all URLs
#
#   remote = RemoteWithExtraUrlParams(..., extra_params='se=prod-tda-...')
#   remote.get('https://google.com/')
#       -> webdriver.Remote.get(https://google.com/?se=tda)
class RemoteWithExtraUrlParams(_ExtraParams, webdriver.Remote): pass
class ChromeWithExtraUrlParams(_ExtraParams, webdriver.Chrome): pass

@pytest.fixture
def selenium_endpoint(data_center):
    username = os.environ['SAUCE_USERNAME']
    access_key = os.environ['SAUCE_ACCESS_KEY']

    if data_center and data_center.lower() == 'eu':
        return "https://{}:{}@ondemand.eu-central-1.saucelabs.com/wd/hub".format(username, access_key)
    else:
        return "https://{}:{}@ondemand.us-west-1.saucelabs.com/wd/hub".format(username, access_key)

def sanitize_se_tag_component(c):
    if not c:
        return ''
    elif not isinstance(c, str):
        c = str(c)
    # so that we can parse the se tag into components later by splitting on '-'
    return c.replace('-', '_').replace('\n', '_')

# `se` tag captures all the information necessary to identify the process, user, parameters and
# particular test file that generated the event. It will be both:
#   1. Passed on to desktop_web as ?se= URL parameter so will show up in
#   demo.sentry.io project issues generated as a result of running the test
#   2. Used for internal reporting of this test automation's own errors (to DSN above,
#   i.e. "empower-tda" project)
# The 'base' part just identifies the who's running the entire suite, in what mode and with what
# global parameters. When run in production (i.e. in GCP or GHA) user will be "prod".
# Example: kosty-tda-direct-testing_my_branch_3
def se_base_tag():
    user = 'prod' if is_production() else get_system_user()
    s = sanitize_se_tag_component
    return f'{s(user)}-tda-{s(CONFIG.mode)}-{s(RUN_ID)}'

# 'prefix' additionally captures the particular test file
# Example se_prefix (no RUN_ID):    prod-tda-mock--desktop_web/test_checkout.py
# Example final se tag:             prod-tda-mock--desktop_web/test_checkout.py-sauce-chrome_windows
@pytest.fixture
def se_prefix(request):
    test_filepath = request.path
    if request.node.name.split('[')[0] != test_filepath.stem:
        raise ValueError(f'TDA expects only 1 function in each test file with the same name as the \
                        file. Please fix {test_filepath}.')
    rel_test_filepath = test_filepath.relative_to(Path(__file__).parent)
    s = sanitize_se_tag_component
    return f'{se_base_tag()}-{s(rel_test_filepath)}'


@contextlib.contextmanager
def _sauce_browser(request, selenium_endpoint, se):
    try:
        test_name = request.node.name
        build_tag = os.environ.get('BUILD_TAG', "Application-Monitoring-TDA")

        options = _browser2class[request.param.browserName]()

        # Testing out if this helps surface web vitals
        if request.param.browserName == 'chrome':
            options.add_argument("--enable-logging")
            options.add_argument("--enable-benchmarking")

        options.set_capability('platformName', request.param.platformName)
        options.set_capability('browserVersion', request.param.browserVersion)
        options.set_capability('sauce:options', {
            'seleniumVersion': '4.8.0',
            'build': build_tag,
            'name': test_name
        })

        browser = RemoteWithExtraUrlParams(
            command_executor=selenium_endpoint,
            options=options,
            keep_alive=True,
            # Note: these tags might not be supported by some frontends, e.g. Vue
            extra_params=urlencode({'se': se})
        )

        browser.implicitly_wait(10)

        sentry_sdk.set_tag("sauceLabsUrl", f"https://app.saucelabs.com/tests/{browser.session_id}")

        # This is specifically for SauceLabs plugin.
        # In case test fails after selenium session creation having this here will help track it down.
        if browser is not None:
            print("SauceOnDemandSessionID={} job-name={}".format(browser.session_id, test_name))
        else:
            raise WebDriverException("Never created!")

        try:
            yield browser
        finally:
            # Teardown starts here
            # report results
            # use the test result to send the pass/fail status to Sauce Labs
            sauce_result = "failed" if request.node.rep_call.failed else "passed"

            # Handler failure scenario, send to Sentry empower-tda
            if sauce_result == "failed":
                sentry_sdk.capture_message("Sauce Result: %s" % (sauce_result))

            browser.execute_script("sauce:job-result={}".format(sauce_result))
            browser.quit()

            # send to Sentry empower-tda, look for tags: se, sauceLabsUrl
            sentry_sdk.capture_message("Selenium Session Done")
            sentry_sdk.flush()

    except Exception as err:
        sentry_sdk.capture_exception(err)


@contextlib.contextmanager
def _local_browser(request, se):
    assert request.param.browserName == 'chrome'  # TODO: add others
    options = webdriver.ChromeOptions()
    options.add_argument("no-sandbox")
    options.add_argument("disable-gpu")
    options.add_argument("disable-dev-shm-usage")
    options.add_argument("headless")
    with ChromeWithExtraUrlParams(
            options=options,
            extra_params=urlencode({'se': se}),
    ) as driver:
        yield driver


@pytest.fixture(params=CONFIG.browsers, ids=[b.param_display for b in CONFIG.browsers])
def desktop_web_driver(request, se_prefix):
    if request.param.remote:
        se = f'{se_prefix}-sauce-{request.param.param_display}'
        sentry_sdk.set_tag("se", se)
        with _sauce_browser(request, request.getfixturevalue('selenium_endpoint'), se) as b:
            yield b
    else:
        se = f'{se_prefix}-local-{request.param.param_display}'
        sentry_sdk.set_tag("se", se)
        with _local_browser(request, se) as b:
            yield b

@pytest.fixture
def android_react_native_emu_driver(request, selenium_endpoint, se_prefix):

    se = f'{se_prefix}-sauce-android10'
    sentry_sdk.set_tag('se', se)
    try:
        release_version = ReleaseVersion.latest_react_native_github_release()

        options = UiAutomator2Options().load_capabilities({
            'deviceName': 'Android GoogleAPI Emulator',
            'platformVersion': '10.0',
            'platformName': 'Android',
            'app': f'https://github.com/sentry-demos/sentry_react_native/releases/download/{release_version}/app-release.apk',
            'sauce:options': {
                'appiumVersion': '1.20.2',
                'build': 'RDC-Android-Python-Best-Practice',
                'name': request.node.name
            },
            'appWaitForLaunch': False
        })

        driver = appiumdriver.Remote(selenium_endpoint, options=options)
        driver.implicitly_wait(20)

        sentry_sdk.set_tag("sauceLabsUrl", f"https://app.saucelabs.com/tests/{driver.session_id}")

        yield driver
        sauce_result = "failed" if request.node.rep_call.failed else "passed"
        driver.execute_script("sauce:job-result={}".format(sauce_result))
        driver.quit()

        # send to Sentry empower-tda, look for tags: se, sauceLabsUrl
        sentry_sdk.capture_message("Selenium Session Done")

    except Exception as err:
        sentry_sdk.capture_exception(err)

@pytest.fixture
def android_emu_driver(request, selenium_endpoint, se_prefix):

    se = f'{se_prefix}-sauce-android10'
    sentry_sdk.set_tag('se', se)
    try:
        release_version = ReleaseVersion.latest_android_github_release()

        options = UiAutomator2Options().load_capabilities({
            'deviceName': 'Android GoogleAPI Emulator',
            'platformVersion': '10.0',
            'platformName': 'Android',
            'app': f'https://github.com/sentry-demos/android/releases/download/{release_version}/app-release.apk',
            'sauce:options': {
                'appiumVersion': '1.20.2',
                'build': 'RDC-Android-Python-Best-Practice',
                'name': request.node.name
            },
            'appWaitForLaunch': False
        })

        driver = appiumdriver.Remote(selenium_endpoint, options=options)
        driver.implicitly_wait(20)

        sentry_sdk.set_tag("sauceLabsUrl", f"https://app.saucelabs.com/tests/{driver.session_id}")

        yield driver
        sauce_result = "failed" if request.node.rep_call.failed else "passed"
        driver.execute_script("sauce:job-result={}".format(sauce_result))
        driver.quit()

        # send to Sentry empower-tda, look for tags: se, sauceLabsUrl
        sentry_sdk.capture_message("Selenium Session Done")

    except Exception as err:
        sentry_sdk.capture_exception(err)
        raise

@pytest.fixture
def ios_react_native_sim_driver(request, selenium_endpoint, se_prefix):

    se = f'{se_prefix}-sauce-ios14.5'
    sentry_sdk.set_tag('se', se)
    try:
        release_version = ReleaseVersion.latest_react_native_github_release()

        options = XCUITestOptions().load_capabilities({
            'appium:deviceName': 'iPhone 11 Simulator',
            'platformName': 'iOS',
            'appium:platformVersion': '14.5',

            'sauce:options': {
                'appiumVersion': '2.0.0',
                'build': 'RDC-iOS-Python-Best-Practice',
                'name': request.node.name,
            },
            'appium:app': f'https://github.com/sentry-demos/sentry_react_native/releases/download/{release_version}/sentry_react_native.app.zip',
        })

        driver = appiumdriver.Remote(selenium_endpoint, options=options)
        driver.implicitly_wait(20)

        sentry_sdk.set_tag("sauceLabsUrl", f"https://app.saucelabs.com/tests/{driver.session_id}")

        yield driver
        sauce_result = "failed" if request.node.rep_call.failed else "passed"
        driver.execute_script("sauce:job-result={}".format(sauce_result))
        driver.quit()

        # send to Sentry empower-tda, look for tags: se, sauceLabsUrl
        sentry_sdk.capture_message("Selenium Session Done")

    except Exception as err:
        sentry_sdk.capture_exception(err)

@pytest.fixture
def ios_sim_driver(request, selenium_endpoint, se_prefix):

    se = f'{se_prefix}-sauce-ios15.5'
    sentry_sdk.set_tag('se', se)
    try:
        release_version = ReleaseVersion.latest_ios_github_release()

        options = XCUITestOptions().load_capabilities({
            'appium:deviceName': 'iPhone 13 Simulator',
            'platformName': 'iOS',
            'appium:platformVersion': '15.5',

            'sauce:options': {
                'appiumVersion': '1.22.3',
                'build': 'RDC-iOS-Mobile-Native',
                'name': request.node.name,
            },
            'appium:app': f'https://github.com/sentry-demos/ios/releases/download/{release_version}/EmpowerPlant_release.zip',
        })

        driver = appiumdriver.Remote(selenium_endpoint, options=options)
        driver.implicitly_wait(20)

        sentry_sdk.set_tag("sauceLabsUrl", f"https://app.saucelabs.com/tests/{driver.session_id}")

        yield driver
        sauce_result = "failed" if request.node.rep_call.failed else "passed"
        driver.execute_script("sauce:job-result={}".format(sauce_result))
        driver.quit()

        # send to Sentry empower-tda, look for tags: se, sauceLabsUrl
        sentry_sdk.capture_message("Selenium Session Done")

    except Exception as err:
        sentry_sdk.capture_exception(err)


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):
    # this sets the result as a test attribute for Sauce Labs reporting.
    # execute all other hooks to obtain the report object
    outcome = yield
    rep = outcome.get_result()

    # set an report attribute for each phase of a call, which can
    # be "setup", "call", "teardown"
    setattr(item, "rep_" + rep.when, rep)

if CONFIG.mode == 'direct':
    def final_report():
        end_time = get_current_time_iso_utc(adjust_seconds=1)
        start = urllib.parse.quote(start_time)
        end = urllib.parse.quote(end_time)
        project = CONFIG.dsn.split('/')[-1]
        print()
        print(f'GENERATED errors: https://demo.sentry.io/issues/?query=se%3A{se_base_tag()}%2A+%21project%3Aempower-tda&start={start}&end={end}')
        print(f'OWN errors:       https://demo.sentry.io/discover/results/?end={end}&field=title&field=se&field=sauceLabsUrl&field=cexp&field=timestamp&project={project}&query=se%3A{se_base_tag()}%2A&queryDataset=error-events&sort=-timestamp&start={start}&yAxis=count%28%29A')

    atexit.register(final_report)
