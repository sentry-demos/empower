#!/bin/bash

# deploy.sh - build, upload artifacts, and deploy or run locally any one or multiple projects
# using *.env for both build-time and runtime environment configuration, where --env parameter 
# specifies which *.env file to use. A special case is --env=local which will run each project's
# 'run_local.sh' script instead of deploying to Google App Engine. If multiple projects are specified on
# the command-line in this local mode, a webserver will be started for each project.
#
# In local mode, you can also specify a custom command to run instead of run_local.sh using the -- separator:
# Usage: ./deploy.sh --env=local flask                 # uses flask/run_local.sh - a setup similar to production
# Usage: ./deploy.sh --env=local react -- npm start    # any command after --, e.g. hot reload server or `cat .env`
# Usage: ./deploy.sh --env=production react            # deploy to production
# Usage: ./deploy.sh --env=staging express spring-boot # multiple projects
# Usage: ./deploy.sh --env=local react flask laravel   # wires all 3 together automatically (see local.env)
#
# Runtime configuration is done by substituting variables in all *.template files found anywhere
# inside each project with the values from *.env file. The output of substitution will be saved in
# the same directory as the template file, but without the .template suffix (and leading undescore, 
# if applicable). For example `./config/_.env.template` will generate `./config/.env` file. It is 
# the responsibility of the app to read the values from config files, e.g. using dotenv package.
#
# In addition to populating templates, the script will magically figure out which GCP secrets are needed
# by run_local.sh and build.sh and fetch them automatically as long as they are defined in *.env.
#
# All variables in *.env are passed into each projects runtime environment / used to fill templates.
# Some variables, however, are special and are additionally used during the build:
#
#   SENTRY_ORG and <PROJECT>_SENTRY_PROJECT <PROJECT>_RELEASE are used in ./bin/sentry-release.sh  
#   to create releases.
#
# Available magic variables and macros:
#
#   __GCP_SECRET__ - replaced with the contents of the secret stored in Google Secret Manager with the
#     same name as the variable it's being assigned to. The secret name can also be different from the 
#     variable name if specified explicitly using the __GCP_SECRET__(<secret_name>) syntax.
#
#   __ENV__ - replaced with the value of the environment variable with the same name as the variable
#     it's being assigned to.
#
#   __IF_DEPLOYING__(<project>, <yes_value>, <no_value>) - replaced with the second or third argument
#     depending on whether the project specified as the 1st argument is one of the projects being deployed.
#
#   __DYNAMIC_VERSION__ - calendar version generated by ./bin/release.sh

echo "[debug] Bash version: $BASH_VERSION" >&2

set -e

# use top-level directory (repository root), to ensure this works regardless of current directory
top=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
export PATH="$PATH:$top/bin"

# Parse CLI arguments
projects=""
env=""
custom_command=""
custom_command_args=""
found_separator=false

for arg in "$@"; do
  if [[ $arg = --env=* ]]; then
    env=$(echo $arg | cut -d '=' -f 2)
    echo "env = $env"
  elif [[ $arg = "--" ]]; then
    found_separator=true
  elif [[ $found_separator = true ]]; then
    if [[ -z "$custom_command" ]]; then
      custom_command="$arg"
    else
      custom_command_args+="$arg "
    fi
  else
    projects+="$arg "
  fi
done

USAGE="[ERROR] Invalid arguments.\n\
Usage: \n\
./deploy.sh --env=local flask                 # uses flask/run_local.sh - a setup similar to production\n\
./deploy.sh --env=local react -- npm start    # any command after --, e.g. hot reload server or 'cat .env'\n\
./deploy.sh --env=production react            # deploy to production\n\
./deploy.sh --env=staging express spring-boot # multiple projects\n\
./deploy.sh --env=local react flask laravel   # wires all 3 together automatically (see local.env)"

# Validate CLI arguments
if [[ "$env" == "" || "$projects" == "" ]]; then
  echo "$USAGE";
  exit 1
fi

# Validate custom command usage
if [[ -n "$custom_command" && "$env" != "local" ]]; then
  echo "[ERROR] Custom commands (-- <command>) are only allowed in local mode (--env=local)"
  exit 1
fi

# Validate that custom commands are only used with a single project
if [[ -n "$custom_command" ]]; then
  # Count the number of projects (trim whitespace and count words)
  project_count=$(echo "$projects" | xargs | wc -w)
  if [[ $project_count -gt 1 ]]; then
    echo "[ERROR] Custom commands (-- <command>) can only be used with a single project, but $project_count projects were specified: $projects"
    exit 1
  fi
fi

if [ ! -f "$top/$env.env" ]; then
  >&2 echo "[ERROR] Missing file $env.env or invalid environment '$env'."
  exit 1
fi

if [ "$env" == "production" ]; then
  if [ -t 0 ] ; then # shell is interactive
    verify_latest_code.sh
  fi
fi

# Check if user is authenticated with Google Cloud before running deployment
if command -v gcloud &> /dev/null ; then
  if [ "$(gcloud auth print-access-token 2>/dev/null | wc -c)" -le 200 ]; then
    echo "You are not authenticated with Google Cloud. Press any key to authenticate... (browser window may open)"
    read -n 1 -s
    gcloud auth login
  else
    echo "Already authenticated with Google Cloud as $ACTIVE_ACCOUNT."
  fi
else
  echo "'gcloud' command not found. The Google Cloud SDK is required."
  echo "Please install it, ensure 'gcloud' is in your PATH, and log in, then re-run the script."
  exit 1
fi

GCP_PROJECT=$(grep '^GCP_PROJECT=' "$top/$env.env" | cut -d'=' -f2-)
if [ -z "$GCP_PROJECT" ]; then
  echo "[ERROR] GCP_PROJECT must be set in $env.env" >&2
  exit 1
fi
gcloud config set project $GCP_PROJECT

# Re-order so backends are launched first
be_projects=""
fe_projects=""
for proj in $projects; do
  if [[ $proj =~ ^(react|vue|next)$ ]]; then
    fe_projects+="$proj "
  else
    be_projects+="$proj "
  fi
done
projects="$be_projects $fe_projects"

function cleanup {
  for pid in $run_sh_pids; do
    # each run_local.sh has it's own cleanup function
    if ps -p $pid > /dev/null; then
      kill $pid 2>/dev/null
    fi
  done
  if [ "$temp_files" != "" ]; then
    rm -f $temp_files # bash only (passed as separate args)
  fi
}
trap cleanup EXIT

run_sh_pids=""
temp_files=""

function wait_check_if_crashed {
  local pid=$1
  local proj=$2
  sleep 1
  echo "$0: Waiting a few seconds before building next project to make sure this server process doesn't crash..."
  sleep 4
  if ! ps -p $pid > /dev/null
  then
    echo "$0 [ERROR]: $proj/run_local.sh exited early, must be a crash."
    exit 1
  fi
}

# Copy environment file to resolved file
cp $top/$env.env $top/.resolved.env
temp_files+="$top/.resolved.env "

# additionally some of the variables are used at build-time, e.g:
# local port in run_local.sh, SENTRY_ORG for sourcemaps upload, *_*_BACKEND logic, etc
projects_re="("$(echo $projects | sed 's/ /|/g' | sed 's/|$//')")" # e.g. (react|flask|laravel)
dynamic_version="$(release.sh)"

# Process __ENV__ magic variables - validate that environment variables exist
env_vars_needed=$(grep -v '^#' $top/.resolved.env | grep -E '=\${__ENV__}$' | cut -d'=' -f1 | tr '\n' ' ')
for var_name in $env_vars_needed; do
  if [ -z "${!var_name}" ]; then
    echo "[ERROR] Environment variable '$var_name' is not defined but is required by ${var_name}=\${__ENV__} in $env.env" >&2
    exit 1
  fi
done

grep -v '^#' $top/.resolved.env | \
  sed 's/ #.*//' | \
  sed -E 's/\$\{__GCP_SECRET__\(([^}]*)\)\}/\$\{__GCP_SECRET__\1\}/g' | \
  sed -E 's/^([^=]*)=\$\{__GCP_SECRET__\}/\1=\$\{__GCP_SECRET__\1\}/g' | \
  sed -E 's/\$\{__IF_DEPLOYING__\('"$projects_re"',[ ]*([^ ]*)[ ]*,.*\)\}/\2/g' | \
  sed -E 's/\$\{__IF_DEPLOYING__\(.*,.*,[ ]*([^ ]*)[ ]*\)\}/\1/g' | \
  sed -E 's/\$\{__DYNAMIC_VERSION__\}/'"$dynamic_version"'/g' > $top/.resolved.tmp

# Now process __ENV__ variables by substituting them with actual environment values
> $top/.resolved.env
while IFS='=' read -r var value || [ -n "$var" ]; do
  # Skip empty lines
  if [[ -z "$var" && -z "$value" ]]; then
    echo "" >> $top/.resolved.env
  elif [[ "$value" == "\${__ENV__}" ]]; then
    # This is a __ENV__ variable, substitute with actual environment value
    echo "$var=${!var}" >> $top/.resolved.env
  else
    echo "$var=$value" >> $top/.resolved.env
  fi
done < $top/.resolved.tmp

# Resolve all variables that reference other variables
while true; do
    prev_content=$(cat $top/.resolved.env)
    envsubst.sh --strict-allow-empty --ignore-prefix=__GCP_SECRET__ --from=$top/.resolved.env < $top/.resolved.env > $top/.resolved.tmp
    new_content=$(cat $top/.resolved.tmp)
    mv $top/.resolved.tmp $top/.resolved.env
    if [ "$prev_content" = "$new_content" ]; then
        break
    fi
done


for proj in $projects; do # bash only

  echo "|||"
  echo "||| $0: $proj"
  echo "|||"

  validate_project.sh $top/$proj

  cd $top/$proj

  # Substitute variables in templates
  templates=$(find . -type f -name "*.template" | sed 's|^\./||')
  for template in $templates; do
    outfile=${template%.template} # remove .template suffix
    if [[ "$outfile" =~ ^_\. ]]; then # remove _ prefix if needed
      outfile=$(echo "$outfile" | sed 's/^_//')
    fi
    if [[ "$env" == "local" && $(basename "$outfile") == "app.yaml" ]]; then
      echo "Skipping app.yaml template processing in local environment"
      continue
    fi
    # Make sure template does not contain any magic variables e.g. __GCP_SECRET__
    if grep -q '\${__' $template; then
      echo "[ERROR] Template '$template' contains \${__???__}. Only source *.env files can use magic variables."
      exit 1
    fi

    tmp_file=.$(basename $template).tmp
    exit_code=0
    set +e
    # Single pass substitution since variables are already resolved in .resolved.env
    # note all secrets should be successfully substituted with '${__GCP_SECRET__VAR_NAME}' strings
    envsubst.sh --strict-allow-quoted-empty --interpret-quotes --from=$top/.resolved.env < $template > $tmp_file
    exit_code=$?
    set -e
    if [ $exit_code -ne 0 ]; then
      echo "[ERROR] Failed to process template file: $template"
      exit 1
    fi
    
    # Don't fetch secrets that are not needed to avoid unnecessary errors
    needed_secrets=$(envsubst.sh --list < $tmp_file | grep '^__GCP_SECRET__' | sed 's/^__GCP_SECRET__//')
    # Fill in secrets
    if [ "$needed_secrets" != "" ]; then
      set +e
      gcp_secret_wrapper.sh $needed_secrets --prefix=__GCP_SECRET__ -- envsubst.sh --strict < $tmp_file > $outfile
      exit_code=$?
      set -e
      if [ $exit_code -ne 0 ]; then
        echo "[ERROR] Failed to fill in secrets in template file: $template"
        exit 1
      fi
    else
      cp $tmp_file $outfile
    fi

    temp_files+="$(pwd)/$tmp_file "
    temp_files+="$(pwd)/$outfile "
  done

  # Process build.sh and run_local.sh scripts using --script mode
  script_secrets="" # secrets used in at least one of the scripts
  script_files="build.sh"
  if [ "$env" == "local" ]; then
    script_files="build.sh run_local.sh"
  fi
  
  for script_file in $script_files; do
    if [ -f "$script_file" ]; then
      echo "Checking what env variables $script_file needs..."
      
      # Step 1: Substitute variables in the script as if it was a template so we can see which secrets are needed
      tmp_script_file=".${script_file}.tmp"
      temp_files+="$(pwd)/$tmp_script_file "
      exit_code=0
      set +e
      envsubst.sh --script --strict-allow-quoted-empty --interpret-quotes --from=$top/.resolved.env < "$script_file" > "$tmp_script_file"
      exit_code=$?
      set -e
      if [ $exit_code -ne 0 ]; then
        echo "[ERROR] Failed to process script file: $script_file"
        exit 1
      fi
      
      # Step 2: Identify GCP secrets
      current_secrets=$(envsubst.sh --script --list < "$tmp_script_file" | grep '^__GCP_SECRET__' | sed 's/^__GCP_SECRET__//' | tr '\n' ' ')
      
      if [ -n "$current_secrets" ]; then
        echo "Found GCP secrets in $script_file: $current_secrets"
        
        # Step 3: Validate that secret names match variable names for script processing
        for secret_name in $current_secrets; do
          # Check if this secret name is used in a variable that has parentheses syntax (different secret name)
          if grep -q "^${secret_name}[ ]*=[ ]*\${__GCP_SECRET__([^}]*)}" "$top/.resolved.env"; then
            echo "[ERROR] '$script_file' references secret '$secret_name' but this variable uses __GCP_SECRET__(<different_name>) syntax which is only supported for *.template files."
            exit 1
          fi
        done
        
        script_secrets="$script_secrets $current_secrets"
      else
        echo "No references to GCP secrets found in $script_file"
      fi
      
      # Clean up tmp file immediately
      rm -f "$tmp_script_file"
    fi
  done

  # Create resolved environment variables array
  # Use array to properly handle variables with spaces and special characters
  RESOLVED_VARS=()
  while IFS='=' read -r var value || [ -n "$var" ]; do
    # Skip empty lines, comments, and GCP secret variables
    # It's important to filter out unresolved variables, e.g. __GCP_SECRET__* because some dotenv libraries
    # like python-dotenv will not override existing variables from environment
    [[ -z "$var" || "$var" =~ ^# || "$value" =~ __GCP_SECRET__ ]] && continue
    # Remove trailing comments from value
    value=$(echo "$value" | sed 's/ #.*$//')
    # Add variable assignment to array
    RESOLVED_VARS+=("$var=$value")
  done < "$top/.resolved.env"

  unset CI # prevents build failing in GitHub Actions
  # if needed build.sh is responsible for calling sentry-release.sh with appropriate arguments
  echo "Running build.sh with resolved environment..."
  set -x
  gcp_secret_wrapper.sh --pass $script_secrets -- env "${RESOLVED_VARS[@]}" ./build.sh
  set +x

  # *** DEPLOY OR RUN ***
  if [ "$env" == "local" ]; then
    if [[ -n "$custom_command" ]]; then
      echo "Running custom command '$custom_command $custom_command_args' with resolved environment..."
      # Note: we assume no secrets inside the custom command, any secrets used must be in *.template files
      env "${RESOLVED_VARS[@]}" $custom_command $custom_command_args &
      pid="$!"
    else
      echo "Running run_local.sh with resolved environment..."
      set -x
      gcp_secret_wrapper.sh --pass $script_secrets -- env "${RESOLVED_VARS[@]}" ./run_local.sh &
      pid="$!"
      set +x
    fi
    run_sh_pids+="$pid " # for later cleanup

    if [[ "$projects" != *"$proj " ]]; then # not last one
      wait_check_if_crashed "$pid" "$proj"
    fi
  else
    if [ -f deploy_project.sh ]; then
      ./deploy_project.sh
    else 
      if [ "$proj" == "spring-boot" ]; then
        mvn clean package appengine:deploy
      else
        gcloud app deploy --version v1 --quiet app.yaml
      fi
    fi
  fi
done

if [ "$env" == "local" ]; then
  sleep 1
  echo "Server process(es) are running. Press Ctrl+C to terminate..."
  while true; do sleep 86400; done
fi
